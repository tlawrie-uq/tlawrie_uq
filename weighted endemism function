weighted_endemism <- function(species_records=mydata, species="SPECIES", longitude="LONGITUDE", latitude="LATITUDE", frame.raster=myraster, weight.type="cell", shapefile_clip="aus_shapefile")
#Description --
  #This is a modified version of Guerin, Ruokolainen and Lowes (2015) endemism function that can be found at https://github.com/GregGuerin/biomap/blob/master/weighted.endemism.R
  #Calculates (taxonomic/species) weighted endemism (species richness inversely weighted by species ranges) across gridded maps
#Usage --
  #For example: weighted_endemism(species_records=mydata, species="SPECIES", longitude="LONGITUDE", latitude="LATITUDE", frame.raster=myraster, weight.type="geo")
#Arguments --
  #species_records
    #A data.frame with rows as individual species records, and columns that include fields for species name, longitude and latitude (see species, longitude, latitude below)
  #species
    #What colname in the supplied species_records contains species names?
  #latitude
    #What colname in the supplied species_records contains latitude values?
  #longitude
    #What colname in the supplied species_records contains longitude values?
  #frame.raster
    #An existing raster object the user can optionally elect to supply as the frame for calculations and mapping (with a specified resolution and extent)
  #weight.type
    # =“cell” is the default and will calculate cell-based range weights (AOO)
    # ="geo" will calculate geographic range weights (EOO)
    # ="richness" sets the weights to 1, which is equivalent to calculating simple species richness 
  #shapefile_clip
    #A polygon clip of the study area (useful in removing marine areas when calculating extent of occurence)
#Details --
  #This implementation of weighted endemism allows alternative calculation of weights for species ranges. Weights can be calculated based on the frequency of occurrence in grid cells (AOO), or alternatively by the geographical size of the species range (EOO). 
#Value --
  #Returns a list of length 4:
    #$WE: vector of weighted endemism scores
    #$WE_Raster: raster map with endemism scores
    #$weights: a named numeric vector of weights used to calculate endemism (equivalent to range size in square kilometres if weight.type="geo")
    #$grid.matrix : a binary data.frame of species against grid cell numbers used in the function which is returned so that it can be re-used in subsequent runs to save time
#Required packages --
   #sp, raster, regeo
{
  
  require(sp)
  require(raster)
  require(rgeos)
  
  if(class(species_records) != "data.frame") {
    stop("Species data must be in a data.frame")
  }
  
  colnames(species_records) <- c("SPECIES", "LATITUDE", "LONGITUDE")  
  if(!("SPECIES" %in% colnames(species_records))) {stop("Cannot locate species data")}
  if(!("LATITUDE" %in% colnames(species_records))) {stop("Cannot locate latitude data")}
  if(!("LONGITUDE" %in% colnames(species_records))) {stop("Cannot locate longitude data")}
  if(any(is.na(species_records$LONGITUDE))) {
    species_records <- species_records[-which(is.na(species_records$LONGITUDE)),] 
  }
  
  if(any(is.na(species_records$LATITUDE))) {
    species_records <- species_records[-which(is.na(species_records$LATITUDE)),] 
  }
  
  coordinates(species_records) <- c("LONGITUDE", "LATITUDE")
  
  cat("Generating frame raster at ", res(frame.raster), " resolution and extent defined by: ", extent(frame.raster)@xmin, extent(frame.raster)@xmax, extent(frame.raster)@ymin, extent(frame.raster)@ymax,"\n")
  if(!(extent(species_records)@xmin >= extent(frame.raster)@xmin & extent(species_records)@xmax <= extent(frame.raster)@xmax & extent(species_records)@ymin >= extent(frame.raster)@ymin & extent(species_records)@ymax <= extent(frame.raster)@ymax)) {
    cat("Some point locations lie outside the frame raster -- trimming these records", "\n")
    species_record_COORDS <- as.data.frame(coordinates(species_records))
    species_records <- species_records[-which(species_record_COORDS$LONGITUDE < extent(frame.raster)@xmin | species_record_COORDS$LONGITUDE > extent(frame.raster)@xmax | species_record_COORDS$LATITUDE < extent(frame.raster)@ymin | species_record_COORDS$LATITUDE > extent(frame.raster)@ymax),]
  }
  
  cat("Generating the gridded occurrence matrix", "\n")
  cell_numbers <- cellFromXY(frame.raster, species_records)
  cell_occur_matrix_prep <- data.frame(cell=cell_numbers, species=species_records$SPECIES, presence=rep(1, length(cell_numbers))) 
  cell_occur_matrix_prep$species <- factor(cell_occur_matrix_prep$species)
  if(any(duplicated(cell_occur_matrix_prep))) {
    cell_occur_matrix_prep <- cell_occur_matrix_prep[-which(duplicated(cell_occur_matrix_prep)),]
  }
  if(any(is.na(cell_occur_matrix_prep$cell))) {
    cell_occur_matrix_prep <- cell_occur_matrix_prep[-which(is.na(cell_occur_matrix_prep$cell)),]
  }
  cell_occur_matrix <- mama(cell_occur_matrix_prep)
  cat("Occurrence matrix generated with dimensions: ", dim(cell_occur_matrix), "\n")
  
  if(weight.type=="cell") {
    cat("Calculating cell-based range weights", "\n")
    inv_rang_cell_occur_mat <- apply(cell_occur_matrix, 2, function(x) {x/sum(x)})
    ranges_prep <- apply(cell_occur_matrix, 2, function(x) {sum(x)})
    ranges<- ranges_prep*mean(values(area(frame.raster))) #Multiply by cell size to get area in km^2
  } 
  
  if(weight.type=="richness") {
    inv_rang_cell_occur_mat <- cell_occur_matrix
    ranges <- apply(cell_occur_matrix, 2, function(x) {x = 1})
  } #cls if(w.t = richness...
  
  if(weight.type=="geo") {	
    spp_ranges <- function(x) {
      n <- 0
      v <- rep(0, length(colnames(cell_occur_matrix)))
      x$SPECIES <- sub(pattern = " ", replacement = ".", x = x$SPECIES, fixed=TRUE)
      x$SPECIES <- sub(pattern = "-", replacement = ".", x = x$SPECIES, fixed=TRUE)
      for (i in colnames(cell_occur_matrix)) {
        n <- n + 1
        temp <- x[which(x$SPECIES == i),]
        colnames(temp) <- colnames(x)
        temp_prep <- data.frame(LONGITUDE=temp$LONGITUDE, LATITUDE=temp$LATITUDE)
        temp<-SpatialPoints(temp_prep, crdref)
        cell_size <- mean(values(area(frame.raster))) #returns size in km^2 
        species_polygon<-try(gConvexHull(temp))
        if (class(species_polygon) != "SpatialPolygons") {
          v[n] <- cell_size
          warning("Cannot compute polygon (either spatial points or spatial lines), returning approximate area of single grid cell for ", i)
        }  #cls if(class(species_polygon) != "SpatialPoly...
        if (class(species_polygon) == "SpatialPolygons") {
          if (is.null(try(intersect(shapefile_clip, species_polygon))) == TRUE) {
            polygon_area <- try((area(species_polygon))/1000000) #returns size in km^2 (convert from m^2)
            if(class(polygon_area) == "try-error") {	
              v[n] <- cell_size
              warning("Cannot compute polygon area, returning approximate area of single grid cell for ", i)
            } #cls if(class(polygon_area)...
            if(class(polygon_area) == "numeric") {
              if(polygon_area < cell_size) {
                v[n] <- cell_size
                warning("Polygon area less than spatial grain of frame.raster, returning approximate area of single grid cell for ", i)
              } #cls if(polygon_area <...
              if(polygon_area >= cell_size) {
                v[n] <- polygon_area
              } #cls if (polygon_area >=...
            } #cls if(class(polyon_area) == "numeric... 
          } # cls if is.null(try(... == TRUE)
          if (is.null(try(intersect(shapefile_clip, species_polygon))) == FALSE) {
            polygon_intersect <- intersect(shapefile_clip, species_polygon)
            polygon_area <- try((sum(area(polygon_intersect)))/1000000) #returns size in km^2 (convert from m^2)
            if(class(polygon_area) == "try-error") {	
              v[n] <- cell_size
              warning("Cannot compute polygon area, returning approximate area of single grid cell for ", i)
            } #cls if(class(polygon_area)...
            if(class(polygon_area) == "numeric") {
              if(polygon_area < cell_size) {
                v[n] <- cell_size
                warning("Polygon area less than spatial grain of frame.raster, returning approximate area of single grid cell for ", i)
              } #cls if(polygon_area <...
              if(polygon_area >= cell_size) {
                v[n] <- polygon_area
              } #cls if (polygon_area >=...
            } #cls if(class(polyon_area) == "numeric... 
          } # cls if is.null(try(... == FALSE)
        } #cls if(class(species_polygon) == "SpatialPo...
        
        cat(n, "species complete:", i, v[n], "\n")
        
      } #cls for (i in colnames...
      
      names(v) <- colnames(cell_occur_matrix)
      return(v)
      
    } #cls spp_ranges function
    
    ranges <- spp_ranges(species_records)
    
  } #cls if weight.type == geo...
  
  cat("Calculating geographic range weights", "\n")
  inv_rang_cell_occur_mat <- cell_occur_matrix
  for(i in 1:ncol(inv_rang_cell_occur_mat)) {
    inv_rang_cell_occur_mat[,i] <- inv_rang_cell_occur_mat[,i]/ranges[which(names(ranges) == colnames(inv_rang_cell_occur_mat)[i])]
  } #cls for(i in 1:ncol...
  
  cat("Calculating weighted endemism", "\n")
  rawEndemism <- rowSums(inv_rang_cell_occur_mat) 
  
  WE_raster <- frame.raster
  WE_raster[] <- NA
  WE_raster[as.numeric(names(rawEndemism))] <- rawEndemism
  outputs <- list(WE = rawEndemism, WE_raster = WE_raster, weights = ranges, grid.matrix = cell_occur_matrix)
  return(outputs)
  
} #cls function
